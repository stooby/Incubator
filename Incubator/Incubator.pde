/*****INCUBATOR_V1.0 *******
  A generative audio sampler instrument that mutates sounds over time
  with a simulated population of sound-seeking and sound-making automata.


  NOTE: this sketch records audio from your system's default audio input (e.g. your laptop's internal soundcard) and writes audio files to the main folder of this sketch
  
  SETUP INSTRUCTIONS:
  1. Install the Minim library to run the sketch:
      a. Within the Processing IDE navigate to: Sketch > Import Library > Add Library
      b. Within the 'Libraries' tab, type "Minim" into the search bar
      c. Select the Minim library and click "Install"
  2. Press "Play" to launch the simulation
  
  OPERATING INSTRUCTIONS:
  • Click the screen to create a sound input node. Sing, yell, whistle, etc. into your microphone input to attract the serpents to the virtual sound source.
      Note: The loudness of your sound-making determines the range (diameter) of the virtual sound source node. Louder sounds will more likely attract serpents from farther away.
            The yellow circle surrounding a serprent's head represents its sensory and vocalization range. Serpents can only perceive sound input and other serpent vocalizations that overlap with their sensory range.
  • When a serpent is w/in range of the sound input node, it will hear your sound and move to be within close proximity of the sound input node.
  • Once the serpent is situated within optimal range of the sound input node, it will start glowing red and recording your audio input for a short duration.
  • After the serpent has completed recording your audio input, it will change color and continue to sit and listen as long as the sound source persists.
  • Sound input nodes will fade and disappear over time if medium to loud sounds aren't detected by your system's audio input.
  • Alternatively, clicking on an existing sound input node will delete it. (Note: Currently, only one sound input node node can be active at a time.)
  • Press any key to generate additional serpents up to the maximum limit as specified by the value of the 'maxSerpentNum' variable below.
  • Once at least one serpent has recorded a sound, the simulation will be able to proceed under its own operation as the autonomous agents vocalize and interact with each other through sound.
       - Each time a serpent hears another serpent's vocalization, there's a chance that its own sound-making parameters (currentl playback rate (pitch) and sample duration) will interpolate towards that of the vocalizing serpent's parameter values
         OR the listening serpent's source sample will change to match the vocalizing serpent's.
       - Through this mechanism, sounds are transmitted through the population and mutate over time.
       - Input new sounds to hear how they evolve through the population over time.
  • After you're done running this sketch, a number of audio files may have been saved within your sketch folder (at least one per each unique sound source input node recorded by a serpent).
      If you'd like to save the audio files generated by the sketch, retitle them or move them to a different location on your computer, otherwise they may be overwritten upon subsequent operations of this sketch.

  Current features:
  - intermediate phases of Minim library integration...
  - system audio input (defaults to computer internal mic) "patched" into sketch - can get current buffer sample values and use throughout sketch
  - audio input amplitude level scales diameter (range) and color of soundSource objects
  - audio recording triggered by serpent listening behavior
  - sound input nodes automatically fade away and get deleted over time in the absence of medium to loud sound input  
  - various serpent movement patterns (random roam, sound-seeking)
  - various serpent behaviors (listening, recording, vocalization)
  - sound sample mutation via serpent vocalization
 
  TODO:  
  - Enable audio file writing of main output
  - Create method to selectively delete individual, groups, and all serpents
  - Create a GUI to show statistics of active population and individual selected serpents, and enable control of audio input/output recording, volume control, and FX processing
  - Enhance visuals to clearly depict diffusion of specific audio samples through population via autogenerated colors (e.g. sound 1 == green, sound 2 == purple, sound 3 == pink, etc.)
  - Enhance visuals (SoundVocClass) to more clearly depict active serpent vocalization and their virtual audio transmission range
  - Implement 'cross-breeding' of sounds between pairs of serpents via audio convolution operations to generate new 'offspring' sounds and serpents
  - Add various audio FX processing to serpent vocalizations
  
  Longer-term TODO:
  - Use Supercollider as the audio-processing engine instead of Minim library. Processing can interface w/ SC via OSC.
  - Create additional sub-classes of alternate automata morphologies and behaviors
  - Interface with Raspberry Pi for integration with larger interactive installation environments
  - Implement a univeral tuning system such that playback rate (pitch) transformations of sounds confrom to user-selected tunings / temperaments (e.g. Just intonation, Pythagorean, Equal temperament, etc.)
  - Consider implementing simple genetic algorithm that mutates sample playback and FX parameters between 'cross-breeding' serpents to produce new 'offspring' sounds and serpents
  
--
This is a work in progress.  Feel free to use, experiment, and contribute:

If you're using this for any of your own projects, I'd love to hear about it! => scott(dot)tooby(at)gmail(dot)com

st, 2016
*/

import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;
import ddf.minim.signals.*;
import ddf.minim.spi.*;
import ddf.minim.ugens.*;

Minim minim;
AudioInput in;
//AudioOutput out;
AudioRecorder recorder; //embed within serpent class...

Serpent[] serpents;
int serpentNum = 0; //counter for last populated index of Serpent[] object array
int maxSerpentNum = 100; //change the matrix size to change the total amount of possible serpents that can be rendered
int segments = 3; //number of segments per serpent
int segLength = 18; //length of each individual segment of the total 'snake' form

ArrayList<SoundSource> sources = new ArrayList<SoundSource>(); //declare arrayList and fill with SoundSource class objects...
boolean sourcesCreated = false;
boolean sourceDeleted = false;
int currentSource = 0; //counter for keeping track of current soundSource object count
int soundCount = 0; //for keeping track of audio file names

ArrayList<SoundVoc> vocs = new ArrayList<SoundVoc>(); //arrayList of SoundVoc class objects...for displaying serpent vocalizations
int currentVoc = 0; //counter for keeping track of current soundVoc object count

float margin = 10.0; //pixel margin around edge of screen where motion targets & generative events occur

void setup()
{
  size(800, 600);
  ellipseMode(CENTER);
  
  minim = new Minim(this);
  //get a mono line-in: sample buffer length is 1024
  //default 44100 sampling rate / 16 bit
  in = minim.getLineIn(Minim.MONO, 1024); 
  //out = minim.getLineOut(Minim.STEREO);
  
  randomSeed(genRandomSeedFromTime());
  
  serpents = new Serpent[maxSerpentNum]; 
  serpents[serpentNum] = new Serpent(segments, segLength, //situate first serpent in a random part of the screen
  random(margin, (width-margin)), random(margin, (height-margin)));
}

void draw()
{
  background(0);
  for (int i = 0; i <= serpentNum; i++)
  { //update&animate all serpents
    serpents[i].sense();
    serpents[i].plotMotion();
    serpents[i].update();
    serpents[i].display();
    serpents[i].vocalize();
    
    /* in progress development to render soundVoc objects...currently buggy....
    if (serpents[i].vocState == true && serpents[i].vocNow == false) //!!!in this order, soundVoc object will display one loop cycle in advance of serpent.display with same currentLevel value.......
    { 
      vocs.add(new SoundVoc(serpents[i].xPos, serpents[i].yPos, serpents[i].selfID)); //create a new soundVoc object to visualize vocalization
      //SoundVoc voc = vocs.get(currentVoc);
      serpents[i].soundVocIndex = currentVoc; //for addressing correct index in array list
      currentVoc++;
    }
    else if (serpents[i].vocState == true && serpents[i].vocNow == true)
    {
      SoundVoc voc = vocs.get(serpents[i].soundVocIndex);
      voc.displayAudio(serpents[i].currentLevel); 
    }
    if (serpents[i].stopVocDisplay == true)
    {
      vocs.remove(serpents[i].soundVocIndex); //remove soundVoc object once vocalization complete
      currentVoc--;
      serpents[i].stopVocDisplay = false;
    }
    */ 
  }
  
  for (int i = 0; i < sources.size(); i++)
  { 
    //float testInLevel = map(mouseY, 0, height, 0.5, 0.0005); //for testing
    //println("mouseY: " + mouseY + " inLevelScale: " + testInLevel);
    SoundSource aSource = sources.get(i);
    //aSource.displayStatic();
    
    if (aSource.soundEnd == true)
    { //remove aSource
      sources.remove(currentSource - 1); //delete soundSource
      currentSource--;
    }
    else//process audio, update, animate soundSources
    {
      //pass the current audio RMS amp level to soundSource display method (effects diameter of visible range) 
      float inLevel = in.left.level(); //get the current audio level of the input buffer
      //println(inLevel);
      aSource.displayAudio(inLevel);
    }    
  }
  
  //float currentOutLevel = out.mix.level();
  //println(currentOutLevel);
}

void keyPressed() //add a serpent if keyPressed
{
  if (key == '0' || key == '1' || key == '2' || key == '3' || key == '4' || key == '5' || key == '6' || key == '7')
  {
    int i = int(key) - 48;
    //println(i);
    serpents[i] = new Serpent(segments, segLength,
      random(margin, (width-margin)), random(margin, (height-margin)));    
  }
  else {
    if (serpentNum < (serpents.length - 1)) //to avoid overflowing amount of object constructor matrix addresses.... 
    {
      serpentNum++;
      serpents[serpentNum] = new Serpent(segments, segLength,
      random(margin, (width-margin)), random(margin, (height-margin))); //generate new serpent in a random location on screen  
    }
  }
}

void mousePressed() //create/delete soundSource wherever mousePressed
{
  float thisX = mouseX;
  float thisY = mouseY;
  
  for (int i = 0; i < sources.size(); i++) //check to see if mouse clicked on existing soundSource or not
  {
    SoundSource aSource = sources.get(i);
    //if mouse click on existing sound source, delete it and remove it from arrayList
    if( (abs(thisX - aSource.x) <= (aSource.originDiam/2)) &&
        (abs(thisY - aSource.y) <= (aSource.originDiam/2))
      )
    {
      sources.remove(i); //delete soundSource
      currentSource--;
      sourceDeleted = true;
      break;
    }
  }
  
  if (sourceDeleted == true){sourceDeleted = false;} //reset flag and exit mouseClicked function if soundSource just deleted (otherwise we'll create a soundSource in the position we just deleted the last one)...
  else
  {//if not clicking on existing soundSource, create a new one and display it
     if (currentSource == 0) //this limits us to have only one active soundSource at a time
     {
       sources.add(new SoundSource(mouseX, mouseY));
       SoundSource aSource = sources.get(currentSource);
       //aSource.display();
       //print("currentSourceAdr= " + currentSource); //for debugging...
       currentSource++;   
       //println(" nextSourceAdr= " + currentSource); 
       //println(sources.size());
     }
  }
}

int genRandomSeedFromTime()
{
  int year = year();
  int month = month();
  int day = day();
  int hour = hour();
  int minute = minute();
  int second = second();
  
  int currentTime = second + minute + hour + day + month + year;
  
  return currentTime;
}